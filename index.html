<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Textler--Markdown Notepad</title>
<style id="app-style">
  @font-face {
    font-family: "iA Writer Duo V";
    src: url("iAWriterDuoV.ttf") format("truetype");
    font-weight: 400;
    font-style: normal;
    font-display: swap;
  }

  @font-face {
    font-family: "iA Writer Duo V";
    src: url("iAWriterDuoV-Italic.ttf") format("truetype");
    font-weight: 400;
    font-style: italic;
    font-display: swap;
  }

  @font-face {
    font-family: "IBM Plex Sans";
    src: url("IBMPlexSans-Regular.ttf") format("truetype");
    font-weight: 400;
    font-style: normal;
    font-display: swap;
  }

  @font-face {
    font-family: "IBM Plex Sans";
    src: url("IBMPlexSans-Italic.ttf") format("truetype");
    font-weight: 400;
    font-style: italic;
    font-display: swap;
  }

  @font-face {
    font-family: "IBM Plex Sans";
    src: url("IBMPlexSans-SemiBold.ttf") format("truetype");
    font-weight: 600;
    font-style: normal;
    font-display: swap;
  }

  :root {
    --ui-font: "SF Pro";
    --text-font: "IBM Plex Sans", -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui, "Helvetica Neue", Arial, sans-serif;
    --editor-font: "iA Writer Duo V";
    --mono-font: ui-monospace, "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  * {
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
  }

  body {
    margin: 0;
    min-height: 100vh;
    font-family: var(--ui-font);
    color: var(--text);
    background:
      radial-gradient(1200px 800px at 10% -10%, var(--bg-2), transparent 60%),
      radial-gradient(900px 700px at 110% 10%, var(--bg-3), transparent 55%),
      var(--bg);
  }

  body.light {
    --bg: #f2ede6;
    --bg-2: #fbf7f2;
    --bg-3: #e3ddd4;
    --panel: #fcf8f3;
    --panel-2: #f4eee6;
    --text: #1f1b16;
    --muted: #6f6258;
    --border: #d8cfc5;
    --accent: #9b6a46;
    --code-bg: #efe7de;
    --code-border: #dacdbf;
    --shadow: rgba(0, 0, 0, 0.12);
  }

  body.dark {
    --bg: #141312;
    --bg-2: #1c1a18;
    --bg-3: #0e0d0c;
    --panel: #1b1917;
    --panel-2: #23201d;
    --text: #f1ece4;
    --muted: #b3a79b;
    --border: #3a342f;
    --accent: #d0a57c;
    --code-bg: #27231f;
    --code-border: #3b332c;
    --shadow: rgba(0, 0, 0, 0.55);
  }

  .app {
    width: min(1200px, 96vw);
    height: min(82vh, 880px);
    margin: clamp(16px, 3vw, 32px) auto;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 16px;
    box-shadow: 0 22px 60px var(--shadow);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    padding: 10px 12px;
    background: var(--panel);
    border-bottom: 1px solid var(--border);
    position: relative;
    transition: opacity 180ms ease, transform 220ms ease;
  }

  .toolbar .group {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .toolbar .sep {
    width: 1px;
    height: 18px;
    background: var(--border);
  }

  .toolbar-right {
    margin-left: auto;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .toolbar button {
    appearance: none;
    border: 1px solid var(--border);
    background: var(--panel-2);
    color: var(--text);
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 12px;
    letter-spacing: 0.04em;
    cursor: pointer;
    transition: background 0.15s ease, transform 0.1s ease;
  }

  .toolbar button:hover {
    background: var(--panel);
  }

  .toolbar button:active {
    transform: translateY(1px);
  }

  .toolbar button:not(.theme-toggle)[aria-pressed="true"] {
    background: var(--panel);
    border-color: color-mix(in srgb, var(--accent) 42%, var(--border));
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  .theme-toggle {
    position: relative;
    width: 32px;
    height: 32px;
    border-radius: 999px;
    padding: 0;
    display: grid;
    place-items: center;
    border: 1px solid var(--border);
    background: var(--panel-2);
    color: var(--text);
    cursor: pointer;
    transition: background 0.15s ease, transform 0.1s ease;
  }

  .theme-toggle:hover {
    background: var(--panel);
  }

  .theme-toggle:active {
    transform: translateY(1px);
  }

  .theme-toggle svg {
    width: 18px;
    height: 18px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    transition: opacity 180ms ease, transform 220ms cubic-bezier(0.22, 1, 0.36, 1);
  }

  body.light .theme-toggle .icon-sun {
    opacity: 1;
    transform: translate(-50%, -50%) rotate(0deg) scale(1);
  }

  body.light .theme-toggle .icon-moon {
    opacity: 0;
    transform: translate(-50%, -50%) rotate(-70deg) scale(0.7);
  }

  body.dark .theme-toggle .icon-sun {
    opacity: 0;
    transform: translate(-50%, -50%) rotate(70deg) scale(0.7);
  }

  body.dark .theme-toggle .icon-moon {
    opacity: 1;
    transform: translate(-50%, -50%) rotate(0deg) scale(1);
  }

  @keyframes theme-pop {
    0% { transform: scale(1); }
    35% { transform: scale(0.92); }
    70% { transform: scale(1.06); }
    100% { transform: scale(1); }
  }

  .theme-toggle.is-animating {
    animation: theme-pop 240ms ease;
  }

  .split {
    display: grid;
    grid-template-columns: 1fr 1fr;
    flex: 1;
    min-height: 0;
  }

  body.notes-mode {
    --ui-font: var(--mono-font);
    --text-font: var(--mono-font);
    --editor-font: var(--mono-font);
  }

  body.notes-mode .app {
    width: min(1400px, 98vw);
  }

  body.notes-mode .split {
    grid-template-columns: minmax(240px, 1fr) minmax(0, 2fr);
  }

  .pane {
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .pane-title {
    padding: 8px 16px;
    font-size: 11px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--muted);
    border-bottom: 1px solid var(--border);
    background: var(--panel-2);
  }

  .preview-pane .pane-title {
    background: var(--panel);
  }

  .editor-pane {
    background: var(--panel-2);
    border-right: 1px solid var(--border);
  }

  .notes-pane {
    display: none;
    background: var(--panel-2);
    border-right: 1px solid var(--border);
  }

  body.notes-mode .notes-pane {
    display: flex;
  }

  body.notes-mode .preview-pane {
    display: none;
  }

  body.notes-mode .editor-pane {
    border-right: none;
  }

  textarea {
    flex: 1;
    min-height: 0;
    border: none;
    background: transparent;
    padding: 22px 20px 40px;
    font-family: var(--editor-font);
    font-size: 15px;
    line-height: 1.6;
    color: var(--text);
    resize: none;
    outline: none;
    tab-size: 2;
  }

  body.notes-mode .editor-textarea {
    font-size: 16px;
    line-height: 1.7;
  }

  body.notes-mode .notes-textarea {
    font-size: 14px;
    line-height: 1.6;
  }

  .preview-pane {
    background: var(--panel);
  }

  body.focus:not(.notes-mode) .split {
    grid-template-columns: 1fr;
  }

  body.focus:not(.notes-mode) .preview-pane {
    display: none;
  }

  body.focus:not(.notes-mode) .editor-pane {
    border-right: none;
  }

  body.focus:not(.notes-mode) .pane-title {
    display: none;
  }

  body.focus .toolbar {
    opacity: 0;
    transform: translateY(-8px);
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
  }

  body.focus .toolbar:hover,
  body.focus .toolbar:focus-within {
    opacity: 1;
    transform: translateY(0);
  }

  body.focus:not(.notes-mode) textarea {
    align-self: center;
    width: min(860px, 100%);
    padding: calc(34px + 5.25em) 44px 90px;
    font-size: 16px;
    line-height: 1.75;
  }

  .preview {
    flex: 1;
    min-height: 0;
    overflow: auto;
    padding: 28px 36px 60px;
  }

  .preview .doc,
  .export .page {
    max-width: 68ch;
    margin: 0 auto;
  }

  .preview, .export .page {
    font-family: var(--text-font);
    font-size: 18px;
    line-height: 1.7;
    color: var(--text);
  }

  .preview p, .export .page p {
    margin: 0 0 1.25em;
  }

  .preview h1, .export .page h1 {
    font-size: 2.4rem;
    line-height: 1.2;
    margin: 0.6em 0 0.4em;
    letter-spacing: -0.02em;
    font-weight: 600;
  }

  .preview h2, .export .page h2 {
    font-size: 1.7rem;
    line-height: 1.3;
    margin: 1.2em 0 0.5em;
    font-weight: 600;
  }

  .preview h3, .export .page h3 {
    font-size: 1.3rem;
    line-height: 1.4;
    margin: 1em 0 0.4em;
    font-weight: 600;
  }

  .preview h1, .preview h2,
  .export .page h1, .export .page h2 {
    text-align: center;
  }

  .preview ul, .preview ol, .export .page ul, .export .page ol {
    margin: 0 0 1.2em;
    padding-left: 1.4em;
  }

  .preview li, .export .page li {
    margin: 0.35em 0;
  }

  .preview a, .export .page a {
    color: var(--accent);
    text-decoration: none;
    border-bottom: 1px solid color-mix(in srgb, var(--accent) 60%, transparent);
  }

  .preview blockquote, .export .page blockquote {
    margin: 2em 0;
    padding: 0;
    border-left: none;
    text-align: center;
    font-style: italic;
    color: var(--text);
  }

  .preview blockquote p, .export .page blockquote p {
    margin: 0 0 1em;
  }

  .preview blockquote p:last-child, .export .page blockquote p:last-child {
    margin-bottom: 0;
  }

  .preview hr, .export .page hr {
    border: 0;
    height: 1px;
    background: currentColor;
    opacity: 0.25;
    margin: 2.5em 0;
  }

  @supports (background: color-mix(in srgb, black 50%, transparent)) {
    .preview hr, .export .page hr {
      background: color-mix(in srgb, var(--text) 70%, transparent);
      opacity: 1;
    }
  }

  .preview code, .export .page code {
    font-family: var(--editor-font);
    font-size: 0.95em;
    background: var(--code-bg);
    border: 1px solid var(--code-border);
    padding: 0.15em 0.35em;
    border-radius: 4px;
  }

  .preview pre, .export .page pre {
    font-family: var(--editor-font);
    background: var(--code-bg);
    border: 1px solid var(--code-border);
    padding: 16px;
    border-radius: 10px;
    overflow: auto;
    margin: 0 0 1.4em;
  }

  .preview pre code, .export .page pre code {
    background: transparent;
    border: none;
    padding: 0;
  }

  .placeholder {
    color: var(--muted);
    font-style: italic;
  }

  .export-body {
    background: var(--bg);
  }

  .export {
    padding: 56px 24px 80px;
  }

  @media (max-width: 900px) {
    .app {
      height: auto;
    }

    .split {
      grid-template-columns: 1fr;
    }

    .editor-pane {
      border-right: none;
      border-bottom: 1px solid var(--border);
    }

    body.notes-mode .notes-pane {
      border-right: none;
      border-bottom: 1px solid var(--border);
    }

    body.notes-mode .editor-pane {
      border-bottom: none;
    }

    .preview {
      padding: 24px;
    }
  }
</style>
</head>
<body class="light">
  <div class="app" role="application">
    <header class="toolbar">
      <div class="group">
        <button data-action="h1" title="Heading 1">H1</button>
        <button data-action="h2" title="Heading 2">H2</button>
        <button data-action="h3" title="Heading 3">H3</button>
      </div>
      <span class="sep"></span>
      <div class="group">
        <button data-action="bold" title="Bold"><strong>B</strong></button>
        <button data-action="italic" title="Italic"><em>I</em></button>
        <button data-action="link" title="Link">Link</button>
      </div>
      <span class="sep"></span>
      <div class="group">
        <button data-action="ul" title="Bulleted List">⋮</button>
        <button data-action="ol" title="Numbered List">1.</button>
        <button data-action="quote" title="Quote">“</button>
        <button data-action="code" title="Code">{}</button>
      </div>
      <span class="sep"></span>
      <div class="toolbar-right">
        <div class="group">
          <button data-action="copy" id="copy-html" title="Copy HTML">Copy HTML</button>
          <button data-action="pdf" id="export-pdf" title="Export PDF">Export PDF</button>
        </div>
        <span class="sep"></span>
        <div class="group">
          <button
            data-action="notes"
            id="notes-toggle"
            type="button"
            title="Enter Notes Mode"
            aria-label="Enter Notes Mode"
            aria-pressed="false"
          >Notes</button>
          <button
            data-action="focus"
            id="focus-toggle"
            type="button"
            title="Enter focus mode"
            aria-label="Enter focus mode"
            aria-pressed="false"
          >Focus</button>
        </div>
        <span class="sep"></span>
        <button
          data-action="theme"
          id="theme-toggle"
          class="theme-toggle"
          type="button"
          title="Toggle theme"
          aria-label="Toggle theme"
          aria-pressed="false"
        >
          <span class="sr-only">Toggle theme</span>
          <svg class="icon-sun" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 4.25v2.2M12 17.55v2.2M5.1 7.1l1.55 1.55M17.35 15.35l1.55 1.55M4.25 12h2.2M17.55 12h2.2M5.1 16.9l1.55-1.55M17.35 8.65l1.55-1.55" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
            <path d="M12 16.2a4.2 4.2 0 1 0 0-8.4 4.2 4.2 0 0 0 0 8.4Z" stroke="currentColor" stroke-width="1.8"/>
          </svg>
          <svg class="icon-moon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M20 14.2A7.8 7.8 0 0 1 9.8 4a6.4 6.4 0 1 0 10.2 10.2Z" stroke="currentColor" stroke-width="1.8" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </header>

    <main class="split">
      <section class="pane notes-pane">
        <div class="pane-title">Notes</div>
        <textarea id="notes" class="notes-textarea" spellcheck="true" wrap="soft" placeholder="Notes for this document..."></textarea>
      </section>
      <section class="pane editor-pane">
        <div class="pane-title">Markdown</div>
        <textarea id="editor" class="editor-textarea" spellcheck="true" wrap="soft"></textarea>
      </section>

      <section class="pane preview-pane">
        <div class="pane-title">Preview</div>
        <div class="preview" id="preview"></div>
      </section>
    </main>
  </div>

<script type="text/plain" id="starter">
# Untitled Note
A calm, focused writing space. Type on the left. Preview on the right.

## Quick syntax
- **Bold** and *italic*
- [Links](https://example.com)
- `Inline code`

> Blockquotes keep the thread of thought together.

```
function hello() {
  return "Hello";
}
```
</script>

<script src="pdf-fonts.js"></script>
<script>
  const editor = document.getElementById('editor');
  const notesEditor = document.getElementById('notes');
  const preview = document.getElementById('preview');
  const toolbar = document.querySelector('.toolbar');
  const copyButton = document.getElementById('copy-html');
  const exportPdfButton = document.getElementById('export-pdf');
  const themeToggleButton = document.getElementById('theme-toggle');
  const focusToggleButton = document.getElementById('focus-toggle');
  const notesToggleButton = document.getElementById('notes-toggle');

  function escapeHTML(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  function escapeAttr(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function smartenPlain(text) {
    return text
      .replace(/\.{3}/g, '&hellip;')
      .replace(/--/g, '&mdash;');
  }

  function renderInline(text) {
    const codes = [];
    text = text.replace(/`([^`]+)`/g, (_, code) => {
      const html = `<code>${escapeHTML(code)}</code>`;
      const token = `@@CODE${codes.length}@@`;
      codes.push(html);
      return token;
    });

    const links = [];
    text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, url) => {
      const safeUrl = escapeAttr(url.trim());
      const safeLabel = escapeHTML(label);
      const html = `<a href="${safeUrl}" target="_blank" rel="noopener">${safeLabel}</a>`;
      const token = `@@LINK${links.length}@@`;
      links.push(html);
      return token;
    });

    text = escapeHTML(text);
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/(^|[^*])\*([^*]+)\*(?!\*)/g, '$1<em>$2</em>');
    text = smartenPlain(text);

    text = text.replace(/@@LINK(\d+)@@/g, (_, i) => links[Number(i)]);
    text = text.replace(/@@CODE(\d+)@@/g, (_, i) => codes[Number(i)]);
    return text;
  }

  function renderMarkdown(md) {
    const lines = md.replace(/\r\n?/g, '\n').split('\n');
    let html = '';
    let i = 0;
    let paragraph = [];

    function flushParagraph() {
      if (paragraph.length) {
        const text = paragraph.join(' ').replace(/\s+/g, ' ').trim();
        if (text) {
          html += `<p>${renderInline(text)}</p>`;
        }
        paragraph = [];
      }
    }

    function collectList(ordered) {
      const tag = ordered ? 'ol' : 'ul';
      const items = [];
      while (i < lines.length) {
        const line = lines[i];
        const match = line.match(ordered ? /^\s*\d+\.\s+(.+)/ : /^\s*[-*+]\s+(.+)/);
        if (!match) break;

        let item = match[1];
        i++;

        while (i < lines.length) {
          const next = lines[i];
          if (next.trim() === '') break;
          if (/^```/.test(next)) break;
          if (/^\s*>/.test(next)) break;
          if (/^\s*(\d+\.\s+|[-*+]\s+)/.test(next)) break;
          if (/^\s+/.test(next)) {
            item += ' ' + next.trim();
            i++;
            continue;
          }
          break;
        }

        items.push(`<li>${renderInline(item.trim())}</li>`);
        if (i < lines.length && lines[i].trim() === '') break;
      }
      html += `<${tag}>${items.join('')}</${tag}>`;
    }

    while (i < lines.length) {
      const line = lines[i];

      if (line.trim() === '') {
        flushParagraph();
        i++;
        continue;
      }

      if (/^```/.test(line)) {
        flushParagraph();
        const langMatch = line.match(/^```([\w-]+)?/);
        const lang = langMatch && langMatch[1] ? langMatch[1] : '';
        i++;
        const codeLines = [];
        while (i < lines.length && !/^```/.test(lines[i])) {
          codeLines.push(lines[i]);
          i++;
        }
        if (i < lines.length) i++;
        const codeHtml = escapeHTML(codeLines.join('\n'));
        html += `<pre><code${lang ? ` class="language-${lang}"` : ''}>${codeHtml}</code></pre>`;
        continue;
      }

      if (/^\s*>/.test(line)) {
        flushParagraph();
        const quoteLines = [];
        while (i < lines.length && /^\s*>/.test(lines[i])) {
          quoteLines.push(lines[i].replace(/^\s*>\s?/, ''));
          i++;
        }
        html += `<blockquote>${renderMarkdown(quoteLines.join('\n'))}</blockquote>`;
        continue;
      }

      const heading = line.match(/^(#{1,3})\s+(.+)/);
      if (heading) {
        flushParagraph();
        const level = heading[1].length;
        html += `<h${level}>${renderInline(heading[2].trim())}</h${level}>`;
        i++;
        continue;
      }

      if (/^\s*[-*+]\s+/.test(line)) {
        flushParagraph();
        collectList(false);
        continue;
      }

      if (/^\s*\d+\.\s+/.test(line)) {
        flushParagraph();
        collectList(true);
        continue;
      }

      if (/^\s*(?:-{3,}|\*{3,}|_{3,})\s*$/.test(line)) {
        flushParagraph();
        html += '<hr />';
        i++;
        continue;
      }

      paragraph.push(line.trim());
      i++;
    }

    flushParagraph();
    return html;
  }

  function render() {
    const raw = editor.value;
    if (raw.trim().length === 0) {
      preview.innerHTML = '<article class="doc"><p class="placeholder">Start writing...</p></article>';
      return;
    }
    preview.innerHTML = `<article class="doc">${renderMarkdown(raw)}</article>`;
  }

  function wrapSelection(before, after, placeholder) {
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    const selected = editor.value.slice(start, end);
    const content = selected || placeholder;
    const replacement = before + content + after;
    editor.setRangeText(replacement, start, end, 'end');
    if (!selected && placeholder) {
      editor.selectionStart = start + before.length;
      editor.selectionEnd = start + before.length + placeholder.length;
    }
    editor.focus();
    render();
  }

  function transformSelectedLines(transformer) {
    const value = editor.value;
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    const lineStart = value.lastIndexOf('\n', start - 1) + 1;
    const lineEnd = value.indexOf('\n', end);
    const endIndex = lineEnd === -1 ? value.length : lineEnd;
    const block = value.slice(lineStart, endIndex);
    const lines = block.split('\n');
    const newLines = lines.map(transformer);
    const newText = newLines.join('\n');
    editor.setRangeText(newText, lineStart, endIndex, 'end');
    editor.selectionStart = lineStart;
    editor.selectionEnd = lineStart + newText.length;
    editor.focus();
    render();
  }

  function insertLink() {
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    const selected = editor.value.slice(start, end);
    const url = 'https://example.com';
    if (selected) {
      const replacement = `[${selected}](${url})`;
      editor.setRangeText(replacement, start, end, 'end');
      const urlStart = start + selected.length + 3;
      editor.selectionStart = urlStart;
      editor.selectionEnd = urlStart + url.length;
    } else {
      const label = 'link text';
      const replacement = `[${label}](${url})`;
      editor.setRangeText(replacement, start, end, 'end');
      editor.selectionStart = start + 1;
      editor.selectionEnd = start + 1 + label.length;
    }
    editor.focus();
    render();
  }

  function insertCode() {
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    const selected = editor.value.slice(start, end);

    if (selected.includes('\n')) {
      const block = '```\n' + selected + '\n```';
      editor.setRangeText(block, start, end, 'end');
      editor.selectionStart = start + 4;
      editor.selectionEnd = start + 4 + selected.length;
    } else {
      wrapSelection('`', '`', 'code');
    }
  }

  function buildExportHtml() {
    const styleText = document.getElementById('app-style').textContent;
    const theme = document.body.classList.contains('dark') ? 'dark' : 'light';
    const content = editor.value.trim().length ? renderMarkdown(editor.value) : '';
    return `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Document</title>
<style>
${styleText}
</style>
</head>
<body class="${theme} export-body">
  <main class="export">
    <article class="page">
${content}
    </article>
  </main>
</body>
</html>`;
  }

  function flashCopy() {
    const original = copyButton.textContent;
    copyButton.textContent = 'Copied';
    copyButton.disabled = true;
    setTimeout(() => {
      copyButton.textContent = original;
      copyButton.disabled = false;
    }, 1200);
  }

  async function copyHtml() {
    const html = buildExportHtml();
    try {
      await navigator.clipboard.writeText(html);
      flashCopy();
    } catch (err) {
      const temp = document.createElement('textarea');
      temp.value = html;
      document.body.appendChild(temp);
      temp.select();
      document.execCommand('copy');
      document.body.removeChild(temp);
      flashCopy();
    }
  }

  function sanitizeFilename(name) {
    const cleaned = String(name || '')
      .replace(/[\\/:*?"<>|]+/g, '-')
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, 120);
    return cleaned || 'Document';
  }

  function buildPdfFilename(md) {
    const match = String(md || '').match(/^\s*#\s+(.+)\s*$/m);
    if (match && match[1]) return sanitizeFilename(match[1]) + '.pdf';
    return 'Document.pdf';
  }

  function downloadBytes(bytes, filename, mimeType) {
    const blob = new Blob([bytes], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1500);
  }

  function parseMarkdownBlocks(md) {
    const html = String(md || '').trim().length ? renderMarkdown(md) : '';
    const doc = new DOMParser().parseFromString(`<body>${html}</body>`, 'text/html');
    const nodes = Array.from(doc.body.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE);

    function collectInlineRuns(node, style, out) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.nodeValue || '';
        if (text) out.push({ text, style });
        return;
      }
      if (node.nodeType !== Node.ELEMENT_NODE) return;
      const tag = node.tagName.toLowerCase();
      const next = { ...style };
      if (tag === 'strong') next.bold = true;
      if (tag === 'em') next.italic = true;
      if (tag === 'code') next.code = true;
      if (tag === 'a') next.link = true;
      for (const child of Array.from(node.childNodes)) collectInlineRuns(child, next, out);
    }

    function inlineRunsFrom(el) {
      const runs = [];
      for (const child of Array.from(el.childNodes)) collectInlineRuns(child, { bold: false, italic: false, code: false, link: false }, runs);
      return runs;
    }

    function blocksFromContainer(containerEl) {
      const out = [];
      const kids = Array.from(containerEl.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE);
      for (const el of kids) {
        const tag = el.tagName.toLowerCase();
        if (tag === 'h1' || tag === 'h2' || tag === 'h3') {
          out.push({ type: 'heading', level: Number(tag[1]), runs: inlineRunsFrom(el) });
          continue;
        }
        if (tag === 'p') {
          out.push({ type: 'paragraph', runs: inlineRunsFrom(el) });
          continue;
        }
        if (tag === 'ul' || tag === 'ol') {
          const ordered = tag === 'ol';
          const items = Array.from(el.children)
            .filter(child => child.tagName && child.tagName.toLowerCase() === 'li')
            .map(li => inlineRunsFrom(li));
          out.push({ type: 'list', ordered, items });
          continue;
        }
        if (tag === 'blockquote') {
          out.push({ type: 'blockquote', blocks: blocksFromContainer(el) });
          continue;
        }
        if (tag === 'hr') {
          out.push({ type: 'hr' });
          continue;
        }
        if (tag === 'pre') {
          const code = el.textContent || '';
          out.push({ type: 'code', text: code.replace(/\n$/, '') });
          continue;
        }
      }
      return out;
    }

    return blocksFromContainer(doc.body);
  }

  const MAC_ROMAN_CODEPOINTS = [
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
    0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1, 0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8,
    0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3, 0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC,
    0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF, 0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8,
    0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211, 0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x03A9, 0x00E6, 0x00F8,
    0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB, 0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153,
    0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA, 0x00FF, 0x0178, 0x2044, 0x20AC, 0x2039, 0x203A, 0xFB01, 0xFB02,
    0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1, 0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4,
    0xF8FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC, 0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7,
  ];

  const MAC_ROMAN_BYTE_FOR_CODEPOINT = (() => {
    const map = new Map();
    for (let i = 0; i < MAC_ROMAN_CODEPOINTS.length; i++) map.set(MAC_ROMAN_CODEPOINTS[i], i);
    return map;
  })();

  const LIGATURE_FI = String.fromCodePoint(0xFB01);
  const LIGATURE_FL = String.fromCodePoint(0xFB02);

  const applyLigatures = (text) => String(text || '')
    .replace(/fi/g, LIGATURE_FI)
    .replace(/fl/g, LIGATURE_FL);

  const shapeText = (text, style) => (style && style.code) ? String(text || '') : applyLigatures(text);

  let pdfFontAssetsPromise = null;

  function base64ToBytes(b64) {
    const bin = atob(String(b64 || ''));
    const out = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i) & 0xff;
    return out;
  }

  async function loadPdfFontAssets(measurer) {
    if (pdfFontAssetsPromise) return pdfFontAssetsPromise;
    pdfFontAssetsPromise = (async () => {
      await document.fonts.load('400 12px \"IBM Plex Sans\"');
      await document.fonts.load('600 12px \"IBM Plex Sans\"');
      await document.fonts.load('italic 12px \"IBM Plex Sans\"');
      await document.fonts.ready;

      // Prefer embedded base64 font payloads so PDF export works when opened via file://
      const embedded = (window.__TEXLER_PDF_FONTS || null);
      const regularBytes = embedded ? base64ToBytes(embedded.regular) : null;
      const italicBytes = embedded ? base64ToBytes(embedded.italic) : null;
      const semiboldBytes = embedded ? base64ToBytes(embedded.semibold) : null;

      if (!regularBytes || !italicBytes || !semiboldBytes) {
        // As a fallback, try fetch() (works when served over http/https).
        const fetchFont = async (src) => {
          const res = await fetch(src);
          if (!res.ok) throw new Error(`Failed to load font: ${src}`);
          return new Uint8Array(await res.arrayBuffer());
        };
        const fetched = await Promise.all([
          regularBytes || fetchFont('IBMPlexSans-Regular.ttf'),
          italicBytes || fetchFont('IBMPlexSans-Italic.ttf'),
          semiboldBytes || fetchFont('IBMPlexSans-SemiBold.ttf'),
        ]);
        return buildPdfFontAssets(measurer, fetched[0], fetched[1], fetched[2]);
      }

      return buildPdfFontAssets(measurer, regularBytes, italicBytes, semiboldBytes);
    })();
    return pdfFontAssetsPromise;
  }

  function buildPdfFontAssets(measurer, regularBytes, italicBytes, semiboldBytes) {
    const buildWidths = (css) => {
      const sizePx = 1000;
      const widths = [];
      for (let code = 32; code <= 222; code++) {
        const cp = MAC_ROMAN_CODEPOINTS[code];
        const ch = String.fromCodePoint(cp);
        const w = measurer.measurePx(ch, css, sizePx);
        widths.push(Math.round((w / sizePx) * 1000));
      }
      return widths;
    };

    const regularCss = '400';
    const semiboldCss = '600';
    const italicCss = 'italic 400';

    return {
      fonts: {
        regular: { bytes: regularBytes, widths: buildWidths(regularCss) },
        bold: { bytes: semiboldBytes, widths: buildWidths(semiboldCss) },
        italic: { bytes: italicBytes, widths: buildWidths(italicCss) },
      },
    };
  }

  async function exportMarkdownToPdfBytes(md) {
    const PAGE = {
      width: 612,
      height: 792,
      marginLeft: 111.4666,
      marginRight: 111.4666,
      marginTop: 91.6,
      marginBottom: 90,
    };
    const baseFontSize = 10.4;
    const lineHeight = 16.0;
    const paragraphAfter = 17.33;
    const docTopOffset = 12.8;
    const quoteIndent = 13.9;
    const listTextIndent = 15.6;
    const listBulletOffset = 4.05;
    const listNumberOffset = 0.93;
    const ruleHeight = 0.8;
    const rulePreGap = 36.0;
    const rulePostGap = 43.2;
    const pageNumberY = 41.0;

    const measurer = (() => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const ptToPx = (pt) => pt * (96 / 72);
      const pxToPt = (px) => px * (72 / 96);
      const fontCss = (style, sizePt) => {
        if (style && style.code) {
          return `${ptToPx(sizePt)}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace`;
        }
        const weight = style && style.bold ? 600 : 400;
        const italic = style && style.italic ? 'italic ' : '';
        return `${italic}${weight} ${ptToPx(sizePt)}px \"IBM Plex Sans\", -apple-system, BlinkMacSystemFont, \"SF Pro Text\", system-ui, \"Helvetica Neue\", Arial, sans-serif`;
      };
      const measurePx = (text, styleOrCss, sizePt) => {
        if (typeof styleOrCss === 'string') {
          ctx.font = `${styleOrCss} ${sizePt}px \"IBM Plex Sans\", -apple-system, BlinkMacSystemFont, \"SF Pro Text\", system-ui, \"Helvetica Neue\", Arial, sans-serif`;
        } else {
          ctx.font = fontCss(styleOrCss, sizePt);
        }
        return ctx.measureText(text).width;
      };
      return { ptToPx, pxToPt, measurePx };
    })();

    const toMacRomanBytes = (text) => {
      const bytes = [];
      for (const ch of String(text || '')) {
        const code = ch.codePointAt(0);
        if (code === 0x09) { bytes.push(0x20); continue; }
        if (code === 0x0D) continue;
        if (code === 0x0A) { bytes.push(0x20); continue; }
        const mapped = MAC_ROMAN_BYTE_FOR_CODEPOINT.get(code);
        if (mapped !== undefined) { bytes.push(mapped); continue; }
        bytes.push(0x3F);
      }
      return bytes;
    };

    const pdfHexString = (text) => {
      const bytes = toMacRomanBytes(text);
      let hex = '';
      for (const b of bytes) hex += b.toString(16).padStart(2, '0');
      return `<${hex}>`;
    };

    const fontKeyForStyle = (style) => {
      if (style && style.code) return 'F5';
      const bold = style && style.bold;
      const italic = style && style.italic;
      if (bold && italic) return 'F3';
      if (bold) return 'F2';
      if (italic) return 'F3';
      return 'F1';
    };

    const mergeStyle = (base, override) => {
      const b = base || { bold: false, italic: false, code: false, link: false };
      const o = override || {};
      if (b.code) {
        return { bold: Boolean(b.bold), italic: Boolean(b.italic), code: true, link: Boolean(b.link) };
      }
      return {
        bold: Boolean(b.bold || o.bold),
        italic: Boolean(b.italic || o.italic),
        code: Boolean(b.code),
        link: Boolean(b.link),
      };
    };

    const normalizeRuns = (runs, styleOverride) => {
      const out = [];
      for (const r of runs || []) {
        const style = mergeStyle(r.style || { bold: false, italic: false, code: false, link: false }, styleOverride);
        const raw = style.code ? String(r.text || '') : String(r.text || '').replace(/\s+/g, ' ');
        const text = shapeText(raw, style);
        if (!text) continue;
        const prev = out[out.length - 1];
        if (prev && prev.style.bold === style.bold && prev.style.italic === style.italic && prev.style.code === style.code && prev.style.link === style.link) {
          prev.text += text;
        } else {
          out.push({ text, style });
        }
      }
      return out;
    };

    const wrapRuns = (runs, sizePt, maxWidthPt, styleOverride) => {
      const maxWidthPx = measurer.ptToPx(maxWidthPt);
      const tokens = [];
      for (const run of normalizeRuns(runs, styleOverride)) {
        const parts = run.style.code ? [run.text] : run.text.split(/(\s+)/);
        for (const part of parts) {
          if (!part) continue;
          if (!run.style.code && /^\s+$/.test(part)) tokens.push({ text: ' ', style: run.style });
          else tokens.push({ text: part, style: run.style });
        }
      }

      const lines = [];
      let line = [];
      let lineWidthPx = 0;

      const pushLine = () => {
        if (line.length) lines.push(line);
        line = [];
        lineWidthPx = 0;
      };

      const appendToken = (tok) => {
        const w = measurer.measurePx(tok.text, tok.style, sizePt);
        line.push(tok);
        lineWidthPx += w;
      };

      const splitLongToken = (tok) => {
        const chars = Array.from(tok.text);
        let idx = 0;
        while (idx < chars.length) {
          if (!line.length) {
            let low = 1;
            let high = chars.length - idx;
            while (low < high) {
              const mid = Math.ceil((low + high) / 2);
              const s = chars.slice(idx, idx + mid).join('');
              const w = measurer.measurePx(s, tok.style, sizePt);
              if (w <= maxWidthPx) low = mid;
              else high = mid - 1;
            }
            const take = Math.max(1, low);
            appendToken({ text: chars.slice(idx, idx + take).join(''), style: tok.style });
            idx += take;
            pushLine();
            continue;
          }
          pushLine();
        }
      };

      for (const tok of tokens) {
        if (tok.text === ' ' && !line.length) continue;
        const w = measurer.measurePx(tok.text, tok.style, sizePt);
        if (!line.length) {
          if (w > maxWidthPx && tok.text.trim()) {
            splitLongToken(tok);
            continue;
          }
          appendToken(tok);
          continue;
        }
        if (lineWidthPx + w <= maxWidthPx) {
          appendToken(tok);
          continue;
        }
        pushLine();
        if (tok.text === ' ') continue;
        if (w > maxWidthPx && tok.text.trim()) {
          splitLongToken(tok);
          continue;
        }
        appendToken(tok);
      }
      pushLine();

      return lines.map(parts => {
        const merged = [];
        for (const p of parts) {
          if (!p.text) continue;
          const prev = merged[merged.length - 1];
          if (prev && prev.style.bold === p.style.bold && prev.style.italic === p.style.italic && prev.style.code === p.style.code && prev.style.link === p.style.link) {
            prev.text += p.text;
          } else {
            merged.push({ text: p.text, style: p.style });
          }
        }
        return merged;
      });
    };

    const wrapTextPreserve = (text, style, sizePt, maxWidthPt) => {
      const maxWidthPx = measurer.ptToPx(maxWidthPt);
      const raw = String(text || '');
      const chars = Array.from(raw.length ? raw : ' ');
      const out = [];
      let idx = 0;
      while (idx < chars.length) {
        let low = 1;
        let high = chars.length - idx;
        while (low < high) {
          const mid = Math.ceil((low + high) / 2);
          const s = chars.slice(idx, idx + mid).join('');
          const w = measurer.measurePx(s, style, sizePt);
          if (w <= maxWidthPx) low = mid;
          else high = mid - 1;
        }
        const take = Math.max(1, low);
        out.push(chars.slice(idx, idx + take).join(''));
        idx += take;
      }
      return out;
    };

    const pages = [];
    let ops = [];
    let lastBaseline = null;
    const pushPage = () => {
      pages.push(ops.join('\n'));
      ops = [];
    };

    const yTop = PAGE.height - PAGE.marginTop;
    let yCursor = yTop - docTopOffset;
    const bottom = PAGE.marginBottom;
    const left = PAGE.marginLeft;
    const right = PAGE.width - PAGE.marginRight;
    const defaultWidth = right - left;

    const ensureSpace = (space) => {
      if (yCursor - space < bottom) {
        pushPage();
        yCursor = yTop;
        lastBaseline = null;
      }
    };

    const drawTextLine = (segments, x, sizePt, color) => {
      const yText = yCursor - sizePt;
      const [r, g, b] = color;
      ops.push(`${r} ${g} ${b} rg`);
      ops.push('BT');
      ops.push(`1 0 0 1 ${x.toFixed(2)} ${yText.toFixed(2)} Tm`);
      let currentFont = null;
      let currentSize = null;
      for (const seg of segments) {
        const text = seg.text;
        if (!text) continue;
        const font = fontKeyForStyle(seg.style);
        const size = sizePt;
        if (font !== currentFont || size !== currentSize) {
          ops.push(`/${font} ${size.toFixed(2)} Tf`);
          currentFont = font;
          currentSize = size;
        }
        ops.push(`${pdfHexString(text)} Tj`);
      }
      ops.push('ET');
      lastBaseline = yText;
    };

    const measureLineWidthPt = (segments, sizePt) => {
      let widthPx = 0;
      for (const seg of segments) {
        if (!seg.text) continue;
        widthPx += measurer.measurePx(seg.text, seg.style, sizePt);
      }
      return measurer.pxToPt(widthPx);
    };

    const renderParagraphLike = (runs, opts) => {
      const sizePt = opts.sizePt;
      const lineHeightPt = opts.lineHeightPt;
      const width = opts.width;
      const color = opts.color;
      const align = opts.align || 'left';
      const lines = wrapRuns(runs, sizePt, width, opts.styleOverride);
      for (const line of lines) {
        ensureSpace(lineHeightPt);
        const x = align === 'center'
          ? opts.x + (opts.width - measureLineWidthPt(line, sizePt)) / 2
          : opts.x;
        drawTextLine(line, x, sizePt, color);
        yCursor -= lineHeightPt;
      }
      yCursor -= opts.afterSpacingPt || 0;
    };

    const renderList = (block, ctx, nextBlock) => {
      let index = 1;
      const afterSpacingPt = nextBlock && nextBlock.type === 'hr' ? 0 : paragraphAfter;
      for (const itemRuns of block.items || []) {
        const lines = wrapRuns(itemRuns, baseFontSize, ctx.width - listTextIndent, ctx.styleOverride);
        let isFirst = true;
        for (const line of lines) {
          ensureSpace(lineHeight);
          if (isFirst) {
            const marker = block.ordered ? `${index}.` : String.fromCodePoint(0x2022);
            const markerX = ctx.x + (block.ordered ? listNumberOffset : listBulletOffset);
            drawTextLine([{ text: marker, style: { bold: false, italic: false, code: false, link: false } }], markerX, baseFontSize, ctx.color);
            isFirst = false;
          }
          drawTextLine(line, ctx.x + listTextIndent, baseFontSize, ctx.color);
          yCursor -= lineHeight;
        }
        index += 1;
      }
      yCursor -= afterSpacingPt;
    };

    const renderRule = () => {
      ensureSpace(rulePreGap + rulePostGap);
      const baseline = lastBaseline !== null ? lastBaseline : (yCursor - baseFontSize);
      const y = baseline - rulePreGap;
      ops.push(`0 0 0 rg`);
      ops.push(`${left.toFixed(2)} ${y.toFixed(2)} ${defaultWidth.toFixed(2)} ${ruleHeight.toFixed(2)} re f`);
      yCursor = y - rulePostGap + baseFontSize;
      lastBaseline = null;
    };

    const renderBlocks = (blocks, ctx) => {
      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i];
        const nextBlock = blocks[i + 1];
        if (block.type === 'heading') {
          renderParagraphLike(block.runs, {
            sizePt: baseFontSize,
            lineHeightPt: lineHeight,
            x: ctx.x,
            width: ctx.width,
            color: ctx.color,
            afterSpacingPt: nextBlock && nextBlock.type === 'hr' ? 0 : paragraphAfter,
            styleOverride: { ...(ctx.styleOverride || {}), bold: true },
            align: 'center',
          });
          continue;
        }
        if (block.type === 'paragraph') {
          renderParagraphLike(block.runs, {
            sizePt: baseFontSize,
            lineHeightPt: lineHeight,
            x: ctx.x,
            width: ctx.width,
            color: ctx.color,
            afterSpacingPt: nextBlock && nextBlock.type === 'hr' ? 0 : paragraphAfter,
            styleOverride: ctx.styleOverride,
          });
          continue;
        }
        if (block.type === 'list') {
          renderList(block, ctx, nextBlock);
          continue;
        }
        if (block.type === 'code') {
          const codeLines = String(block.text || '').replace(/\r\n?/g, '\n').split('\n');
          const sizePt = baseFontSize;
          const codeStyle = { bold: false, italic: false, code: true, link: false };
          for (const rawLine of codeLines) {
            const chunks = wrapTextPreserve(rawLine, codeStyle, sizePt, ctx.width);
            for (const chunk of chunks) {
              ensureSpace(lineHeight);
              drawTextLine([{ text: chunk, style: codeStyle }], ctx.x, sizePt, ctx.color);
              yCursor -= lineHeight;
            }
          }
          yCursor -= paragraphAfter;
          continue;
        }
        if (block.type === 'blockquote') {
          renderBlocks(block.blocks || [], { x: ctx.x + quoteIndent, width: ctx.width - quoteIndent, color: ctx.color, styleOverride: { italic: true } });
          continue;
        }
        if (block.type === 'hr') {
          renderRule();
          continue;
        }
      }
    };

    const fontAssets = await loadPdfFontAssets(measurer);

    const blocks = parseMarkdownBlocks(md);
    renderBlocks(blocks, { x: left, width: defaultWidth, color: [0, 0, 0] });
    pushPage();

    const encoder = new TextEncoder();
    const objects = [null];
    const addObject = (content) => {
      objects.push({ type: 'string', content });
      return objects.length - 1;
    };
    const addStreamObject = (data, extraDict) => {
      objects.push({ type: 'stream', data, extraDict: extraDict || '' });
      return objects.length - 1;
    };
    const setObject = (id, content) => { objects[id] = { type: 'string', content }; };

    const pagesId = addObject('');
    const catalogId = addObject(`<< /Type /Catalog /Pages ${pagesId} 0 R >>`);
    const now = new Date();
    const pad2 = (n) => String(n).padStart(2, '0');
    const creation = `D:${now.getFullYear()}${pad2(now.getMonth() + 1)}${pad2(now.getDate())}${pad2(now.getHours())}${pad2(now.getMinutes())}${pad2(now.getSeconds())}`;
    const infoId = addObject(`<< /Producer ${pdfHexString('Texler')} /CreationDate ${pdfHexString(creation)} >>`);

    const fontDescriptors = {
      regular: {
        flags: 32,
        italicAngle: 0,
        bbox: [-260, -245, 1241, 1119],
        ascent: 1025,
        descent: -275,
        capHeight: 911,
        xHeight: 683,
        maxWidth: 1306,
      },
      bold: {
        flags: 32,
        italicAngle: 0,
        bbox: [-307, -275, 1332, 1150],
        ascent: 1025,
        descent: -275,
        capHeight: 911,
        xHeight: 683,
        maxWidth: 1382,
      },
      italic: {
        flags: 96,
        italicAngle: -11,
        bbox: [-245, -245, 1180, 1120],
        ascent: 1025,
        descent: -275,
        capHeight: 911,
        xHeight: 683,
        maxWidth: 1262,
      },
    };

    const createEmbeddedFont = (postScriptName, fontData, widths, metrics) => {
      const fontFileId = addStreamObject(fontData, '');
      const desc = `<< /Type /FontDescriptor /FontName /${postScriptName} ` +
        `/Flags ${metrics.flags} /FontBBox [${metrics.bbox.join(' ')}] ` +
        `/ItalicAngle ${metrics.italicAngle} /Ascent ${metrics.ascent} /Descent ${metrics.descent} ` +
        `/CapHeight ${metrics.capHeight} /StemV 0 /XHeight ${metrics.xHeight} /MaxWidth ${metrics.maxWidth} ` +
        `/FontFile2 ${fontFileId} 0 R >>`;
      const fontDescId = addObject(desc);
      const widthsStr = widths.map(w => Math.max(0, Math.round(w))).join(' ');
      const fontDict = `<< /Type /Font /Subtype /TrueType /BaseFont /${postScriptName} ` +
        `/FontDescriptor ${fontDescId} 0 R /Encoding /MacRomanEncoding ` +
        `/FirstChar 32 /LastChar 222 /Widths [ ${widthsStr} ] >>`;
      return addObject(fontDict);
    };

    const fontRegularId = createEmbeddedFont('TEXLR+IBMPlexSans', fontAssets.fonts.regular.bytes, fontAssets.fonts.regular.widths, fontDescriptors.regular);
    const fontBoldId = createEmbeddedFont('TEXLR+IBMPlexSans-SemiBold', fontAssets.fonts.bold.bytes, fontAssets.fonts.bold.widths, fontDescriptors.bold);
    const fontItalicId = createEmbeddedFont('TEXLR+IBMPlexSans-Italic', fontAssets.fonts.italic.bytes, fontAssets.fonts.italic.widths, fontDescriptors.italic);
    const monoFontId = addObject(`<< /Type /Font /Subtype /Type1 /BaseFont /Courier >>`);

    const fontResources = `<< /Font << /F1 ${fontRegularId} 0 R /F2 ${fontBoldId} 0 R /F3 ${fontItalicId} 0 R /F5 ${monoFontId} 0 R >> >>`;

    const kids = [];
    for (let i = 0; i < pages.length; i++) {
      const pageOps = pages[i];
      const pageNumber = String(i + 1);
      const pageWidth = measureLineWidthPt([{ text: pageNumber, style: { bold: false, italic: false, code: false, link: false } }], baseFontSize);
      const pageX = (PAGE.width - pageWidth) / 2;
      const numberOps = [];
      numberOps.push('0 0 0 rg');
      numberOps.push('BT');
      numberOps.push(`1 0 0 1 ${pageX.toFixed(2)} ${pageNumberY.toFixed(2)} Tm`);
      numberOps.push(`/F1 ${baseFontSize.toFixed(2)} Tf`);
      numberOps.push(`${pdfHexString(pageNumber)} Tj`);
      numberOps.push('ET');
      const contentData = encoder.encode(`${pageOps}\n${numberOps.join('\n')}\n`);
      const contentId = addStreamObject(contentData, '');
      const pageId = addObject(
        `<< /Type /Page /Parent ${pagesId} 0 R ` +
        `/MediaBox [0 0 ${PAGE.width} ${PAGE.height}] ` +
        `/Resources ${fontResources} ` +
        `/Contents ${contentId} 0 R >>`
      );
      kids.push(`${pageId} 0 R`);
    }
    setObject(pagesId, `<< /Type /Pages /Kids [${kids.join(' ')}] /Count ${kids.length} >>`);

    const chunks = [];
    const pushStr = (s) => chunks.push(encoder.encode(s));
    chunks.push(encoder.encode('%PDF-1.4\n'));
    chunks.push(new Uint8Array([0x25, 0xE2, 0xE3, 0xCF, 0xD3, 0x0A]));

    const offsets = [0];
    let offset = chunks[0].length + chunks[1].length;
    for (let id = 1; id < objects.length; id++) {
      offsets[id] = offset;
      const obj = objects[id];
      if (obj.type === 'stream') {
        const dict = obj.extraDict ? `<< ${obj.extraDict} /Length ${obj.data.length} >>` : `<< /Length ${obj.data.length} >>`;
        const header = `${id} 0 obj\n${dict}\nstream\n`;
        const footer = `\nendstream\nendobj\n`;
        const headerBuf = encoder.encode(header);
        const footerBuf = encoder.encode(footer);
        chunks.push(headerBuf);
        chunks.push(obj.data);
        chunks.push(footerBuf);
        offset += headerBuf.length + obj.data.length + footerBuf.length;
      } else {
        const objStr = `${id} 0 obj\n${obj.content}\nendobj\n`;
        const buf = encoder.encode(objStr);
        chunks.push(buf);
        offset += buf.length;
      }
    }

    const xrefStart = offset;
    let xref = `xref\n0 ${objects.length}\n`;
    xref += `0000000000 65535 f \n`;
    for (let id = 1; id < objects.length; id++) {
      const off = String(offsets[id]).padStart(10, '0');
      xref += `${off} 00000 n \n`;
    }
    pushStr(xref);

    const trailer =
      `trailer\n<< /Size ${objects.length} /Root ${catalogId} 0 R /Info ${infoId} 0 R >>\n` +
      `startxref\n${xrefStart}\n%%EOF\n`;
    pushStr(trailer);

    const total = chunks.reduce((sum, c) => sum + c.length, 0);
    const out = new Uint8Array(total);
    let pos = 0;
    for (const c of chunks) {
      out.set(c, pos);
      pos += c.length;
    }
    return out;
  }

  async function exportPdf() {
    const original = exportPdfButton ? exportPdfButton.textContent : 'Export PDF';
    if (exportPdfButton) {
      exportPdfButton.textContent = 'Exporting…';
      exportPdfButton.disabled = true;
    }

    try {
      const md = editor.value || '';
      const bytes = await exportMarkdownToPdfBytes(md);
      downloadBytes(bytes, buildPdfFilename(md), 'application/pdf');
    } finally {
      if (exportPdfButton) {
        exportPdfButton.textContent = original;
        exportPdfButton.disabled = false;
      }
    }
  }

  function toggleTheme() {
    const body = document.body;
    body.classList.toggle('dark');
    body.classList.toggle('light');
    animateThemeButton();
    syncThemeToggle();
  }

  function animateThemeButton() {
    if (!themeToggleButton) return;
    themeToggleButton.classList.remove('is-animating');
    void themeToggleButton.offsetWidth; // restart animation
    themeToggleButton.classList.add('is-animating');
    themeToggleButton.addEventListener('animationend', () => {
      themeToggleButton.classList.remove('is-animating');
    }, { once: true });
  }

  function syncThemeToggle() {
    if (!themeToggleButton) return;
    const isDark = document.body.classList.contains('dark');
    themeToggleButton.setAttribute('aria-pressed', String(isDark));
    themeToggleButton.setAttribute('aria-label', isDark ? 'Switch to light mode' : 'Switch to dark mode');
    themeToggleButton.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
  }

  function readSetting(key) {
    try {
      return localStorage.getItem(key);
    } catch {
      return null;
    }
  }

  function writeSetting(key, value) {
    try {
      localStorage.setItem(key, value);
    } catch {
      // ignore
    }
  }

  function readJsonSetting(key, fallback) {
    const raw = readSetting(key);
    if (!raw) return fallback;
    try {
      return JSON.parse(raw);
    } catch {
      return fallback;
    }
  }

  function writeJsonSetting(key, value) {
    writeSetting(key, JSON.stringify(value));
  }

  function slugifyTitle(text) {
    return String(text || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .slice(0, 64);
  }

  function getDocumentKey(md) {
    const match = String(md || '').match(/^\s*#\s+(.+)\s*$/m);
    const title = match && match[1] ? match[1].trim() : 'untitled';
    return slugifyTitle(title) || 'untitled';
  }

  const NOTES_STORAGE_KEY = 'texler_notes_by_doc';
  let notesByDoc = readJsonSetting(NOTES_STORAGE_KEY, {});
  let currentDocKey = null;
  let notesModePrevFocus = null;

  function persistNotesStore() {
    writeJsonSetting(NOTES_STORAGE_KEY, notesByDoc);
  }

  function syncNotesForDocument(nextKey) {
    if (!notesEditor) return;
    const prevKey = currentDocKey;
    if (prevKey && prevKey !== nextKey) {
      const prevNotes = notesByDoc[prevKey];
      if (prevNotes && !notesByDoc[nextKey]) {
        notesByDoc[nextKey] = prevNotes;
        delete notesByDoc[prevKey];
        persistNotesStore();
      }
    }
    currentDocKey = nextKey;
    notesEditor.value = notesByDoc[currentDocKey] || '';
  }

  function syncFocusToggle() {
    if (!focusToggleButton) return;
    const isFocus = document.body.classList.contains('focus');
    const isNotes = document.body.classList.contains('notes-mode');
    focusToggleButton.setAttribute('aria-pressed', String(isFocus));
    if (isNotes) {
      focusToggleButton.disabled = true;
      focusToggleButton.setAttribute('aria-disabled', 'true');
      focusToggleButton.textContent = 'Focus';
      focusToggleButton.title = 'Focus mode is locked in Notes Mode';
      focusToggleButton.setAttribute('aria-label', 'Focus mode locked in Notes Mode');
      return;
    }
    focusToggleButton.disabled = false;
    focusToggleButton.removeAttribute('aria-disabled');
    focusToggleButton.textContent = isFocus ? 'Exit Focus' : 'Focus';
    focusToggleButton.title = isFocus ? 'Exit focus mode (Esc)' : 'Enter focus mode (⌘⇧F / Ctrl⇧F)';
    focusToggleButton.setAttribute('aria-label', focusToggleButton.title);
  }

  function setFocusMode(enabled) {
    document.body.classList.toggle('focus', Boolean(enabled));
    writeSetting('texler_focus', enabled ? '1' : '0');
    syncFocusToggle();
    if (enabled) editor.focus();
  }

  function toggleFocus() {
    if (document.body.classList.contains('notes-mode')) return;
    setFocusMode(!document.body.classList.contains('focus'));
  }

  function syncNotesToggle() {
    if (!notesToggleButton) return;
    const isNotes = document.body.classList.contains('notes-mode');
    notesToggleButton.setAttribute('aria-pressed', String(isNotes));
    notesToggleButton.textContent = isNotes ? 'Exit Notes' : 'Notes';
    notesToggleButton.title = isNotes ? 'Exit Notes Mode (⌘⇧N / Ctrl⇧N)' : 'Enter Notes Mode (⌘⇧N / Ctrl⇧N)';
    notesToggleButton.setAttribute('aria-label', notesToggleButton.title);
  }

  function setNotesMode(enabled) {
    const body = document.body;
    const isEnabled = body.classList.contains('notes-mode');
    if (enabled === isEnabled) return;
    if (enabled) {
      notesModePrevFocus = body.classList.contains('focus');
      body.classList.add('notes-mode');
      setFocusMode(true);
    } else {
      body.classList.remove('notes-mode');
      if (notesModePrevFocus === false) {
        setFocusMode(false);
      }
      notesModePrevFocus = null;
    }
    syncNotesToggle();
    syncFocusToggle();
  }

  function toggleNotesMode() {
    setNotesMode(!document.body.classList.contains('notes-mode'));
  }

  toolbar.addEventListener('click', (event) => {
    const button = event.target.closest('button[data-action]');
    if (!button) return;
    const action = button.dataset.action;

    if (action === 'bold') return wrapSelection('**', '**', 'bold text');
    if (action === 'italic') return wrapSelection('*', '*', 'italic text');
    if (action === 'link') return insertLink();
    if (action === 'h1') return transformSelectedLines(line => {
      if (!line.trim()) return line;
      return '# ' + line.replace(/^\s*#{1,3}\s+/, '');
    });
    if (action === 'h2') return transformSelectedLines(line => {
      if (!line.trim()) return line;
      return '## ' + line.replace(/^\s*#{1,3}\s+/, '');
    });
    if (action === 'h3') return transformSelectedLines(line => {
      if (!line.trim()) return line;
      return '### ' + line.replace(/^\s*#{1,3}\s+/, '');
    });
    if (action === 'ul') return transformSelectedLines(line => {
      if (!line.trim()) return line;
      const stripped = line.replace(/^\s*(\d+\.|[-*+])\s+/, '');
      return '- ' + stripped;
    });
    if (action === 'ol') {
      let index = 1;
      return transformSelectedLines(line => {
        if (!line.trim()) return line;
        const stripped = line.replace(/^\s*(\d+\.|[-*+])\s+/, '');
        return `${index++}. ${stripped}`;
      });
    }
    if (action === 'quote') return transformSelectedLines(line => {
      if (!line.trim()) return line;
      if (/^\s*>/.test(line)) return line;
      return '> ' + line;
    });
    if (action === 'code') return insertCode();
    if (action === 'copy') return copyHtml();
    if (action === 'pdf') return exportPdf().catch((err) => console.error(err));
    if (action === 'theme') return toggleTheme();
    if (action === 'notes') return toggleNotesMode();
    if (action === 'focus') return toggleFocus();
  });

  document.addEventListener('keydown', (event) => {
    const key = String(event.key || '').toLowerCase();
    if ((event.metaKey || event.ctrlKey) && event.shiftKey && key === 'n') {
      event.preventDefault();
      toggleNotesMode();
      return;
    }
    if ((event.metaKey || event.ctrlKey) && event.shiftKey && key === 'f') {
      event.preventDefault();
      toggleFocus();
      return;
    }
    if (key === 'escape' && document.body.classList.contains('focus') && !document.body.classList.contains('notes-mode')) {
      event.preventDefault();
      setFocusMode(false);
    }
  });

  function runNotesModeTests() {
    const results = [];
    const assert = (condition, message) => {
      const ok = Boolean(condition);
      results.push({ ok, message });
      if (!ok) console.error('Notes Mode test failed:', message);
    };

    const wasNotes = document.body.classList.contains('notes-mode');
    if (!wasNotes) setNotesMode(true);

    const previewPane = document.querySelector('.preview-pane');
    const previewHidden = !previewPane || getComputedStyle(previewPane).display === 'none';
    assert(previewHidden, 'Preview hidden in Notes Mode');
    assert(document.body.classList.contains('focus'), 'Focus enabled in Notes Mode');
    assert(document.body.classList.contains('notes-mode'), 'Notes Mode class applied');

    const notesPane = document.querySelector('.notes-pane');
    const editorPane = document.querySelector('.editor-pane');
    if (notesPane && editorPane) {
      const notesRect = notesPane.getBoundingClientRect();
      const editorRect = editorPane.getBoundingClientRect();
      if (window.innerWidth > 900) {
        const ratio = notesRect.width / (notesRect.width + editorRect.width);
        assert(ratio > 0.3 && ratio < 0.4, 'Notes pane is ~33% width');
      } else {
        assert(notesRect.top < editorRect.top, 'Notes pane stacks above editor on small screens');
      }
    } else {
      assert(false, 'Notes and editor panes exist');
    }

    const editorFont = getComputedStyle(editor).fontFamily || '';
    assert(editorFont.includes('ui-monospace') || editorFont.includes('SF Mono') || editorFont.includes('Menlo'), 'Notes Mode uses a system monospace font');

    if (!wasNotes) setNotesMode(false);

    const failed = results.filter(r => !r.ok);
    if (!failed.length) console.log('Notes Mode tests passed');
    return results;
  }

  editor.value = document.getElementById('starter').textContent.trim();
  currentDocKey = getDocumentKey(editor.value);
  syncNotesForDocument(currentDocKey);
  editor.addEventListener('input', () => {
    render();
    const nextKey = getDocumentKey(editor.value);
    if (nextKey !== currentDocKey) {
      syncNotesForDocument(nextKey);
    }
  });
  if (notesEditor) {
    notesEditor.addEventListener('input', () => {
      if (!currentDocKey) currentDocKey = getDocumentKey(editor.value);
      notesByDoc[currentDocKey] = notesEditor.value;
      persistNotesStore();
    });
  }
  render();
  syncThemeToggle();

  const focusSaved = readSetting('texler_focus');
  if (focusSaved === '1') setFocusMode(true);
  syncFocusToggle();
  syncNotesToggle();

  const params = new URLSearchParams(window.location.search);
  if (params.has('test')) runNotesModeTests();
</script>
</body>
</html>
